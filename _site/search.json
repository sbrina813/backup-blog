[
  
    {
      "title"    : "SPA and MVC in AngularJS",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/09/MVC-AngularJS.html",
      "date"     : "2015-09-09 00:00:00 -0700"
     "content"  : "Extract from the book of Pro AngularJS—Adam FreemanRound-Trip App vs Single Page AppRound-trip App:The browser requests an initial HTML document from the server. User interactions-such as clicking a link or submitting a form-led the browser to request and receive a completely new HTML document. In this kind of application, the browser is essentially a rending engine for HTML content, and all of the applicaation logic and data resides on the server. The browser makes a series of stateless HTTP requests that the server handles by generating HTML documents danamically.Serious drawbacks to round-trip apps : They make the user wait while the next HTML document is requested and roaded, they require a large server-side infrastructure to process all of the requests and manage all of the application state, and they require a lot of bandwidth because each HTML document has to be self-contained(a lot of same content-like header, footer- being included in each response from the server)Single page application(SPA): An initial HTML document is sent to the browser, but user interactions lead to Ajax requests for small fragments of HTML or data inserted into the existing set of elements being displayed to the user. The initial HTML document is never be reloaded or replaced, and the user can continue to interact with the existing HTML while the Ajax requests are being performed asychronously, even if that just means seeing a “data loading” message.Ther is gradual tendency for current web app projects to move toward the single page application model, because the benefits of using the MVC pattern really start to manifest themselves in larger and more complex projects.Understanding the MVC PatternThe key to applying the MVC pattern is to implement the key premise of a separation of concerns, in which the data model in the application is decoupled from the business and presentation logic. In the client-side web development, this means separating the data, the logic that oprates on that data, and the HTML elements used to display the data. The result is a client-side application that is easier to develop,maintain and test.Models—the M in MVC,contains the data that users work with. There are two broad types of model. view models, which represent just data passed from the controller to the view, and domian models, which contain the data in a business domain, along with the operations, transformation, and rules for creating, storing and manipulating that data, collectively referred to as the model logic.  A model should:      Contain domain data    Contain the logic for creating,managing and modifying the domain data    Provide a clean API that exposes the model data and operations on it    should not:      Expose details of how the model data is obtained or managed( in other words, details of the data storage mechanism or the remote webservice should not be exposed to controllers and views)    Contain logic that transforms the model based on user interaction( because this is the controller’s job)    Contain logic for displaying to the user( this is the view’s job)  Controllers are the connective tissue in an AngularJS web application, acting as conduits between the data model and views. Controllers add business logic(known as behavior) to scopes, which are subsets of the model.  A controller should:      Contain the logic required to initialize the scope    Contain the logic/behaviors required by the view to present data from the scope    Contain the logic/behaviors required to update the scope based on the user interaction    Should not:      Contain logic that manipulates the DOM (that is the job of the view)    Contain logic that manages the persistence of data (that is the job of the model)    Manipulate data outside of the scope  Views are defined using HTML elements that are enhanced and that generate HTML by the use of data bindings and directives. It is the AngularJS directives that make views so flexible, and they transform HTML elements into the foundation for dynamic web apps.  Virws should:            Contain the logic and markup required to present data to the userShould not:        Contain complex logic （this is better placed in a controller)    Contain logic that creates, stores or manipulates the domain model  "
    } ,
  
    {
      "title"    : "this in JavaScript",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/08/this-in-javascript.html",
      "date"     : "2015-09-08 00:00:00 -0700"
     "content"  : "Extrct form JavaScriptissexyNote that when we use strict mode, this holds the value of undefined in global functions and in anonymous functions that are not bound to any object.  Even though it appears this refers to the object where it isdefined, it is not until an object invokes the this Function thatthis is actually assigned a value. And the value it is assigned is based exclusively on the object that invokes the this Function. thishas the value of the invoking object in most circumstances. However,there are a few scenarios where this does not have the value of theinvoking object.The use of this in the global scopewhen we use this in a global function, it refers to (and has the value of) the global window object (not in strict mode though, as noted earlier) that is the main container of the entire JavaScript application or web page.When this is most misunderstood and becomes trickyThe this keyword is most misunderstood when we borrow a method that uses this, when we assign a method that uses this to a variable, when a function that uses this is passed as a callback function, and when this is used inside a closure—an inner function.4 Examples need to digest for future useAlways remember that this is assigned the value of the object that invoked the this Function."
    } ,
  
    {
      "title"    : "Bind, call and Apply in JavaScript",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/08/Bind-apply-call-in-JavaScript.html",
      "date"     : "2015-09-08 00:00:00 -0700"
     "content"  : "Extrct form JavaScriptissexyJavaScript’s Bind Allows Us to Set the this Value on Methods bind () allows us to easily set which specific object will be bound to this when a function or method is invoked.//            &lt;button&gt;Get Random Person&lt;/button&gt;​​//        &lt;input type="text"&gt;​​​​var user = {    data        :[        {name:"T. Woods", age:37},        {name:"P. Mickelson", age:43}    ],    clickHandler:function (event) {        var randomNum = ((Math.random () * 2 | 0) + 1) - 1; // random number between 0 and 1​​        // This line is adding a random person from the data array to the text field​        $ ("input").val (this.data[randomNum].name + " " + this.data[randomNum].age);    }​}​​// Assign an eventHandler to the button's click event​$ ("button").click (user.clickHandler); When you click the button, you get an error because this in the clickHandler () method is bound to the button HTML element, since that is the object that the clickHandler method is executed on. To fix this problem, we could bind $ ("button").click (user.clickHandler.bind (user)); use this  // This data variable is a global variable​            var data = [                {name:"Samantha", age:12},                {name:"Alexis", age:14}            ]​            var user = {                // local data variable​                data    :[                    {name:"T. Woods", age:37},                    {name:"P. Mickelson", age:43}                ],                showData:function (event) {                    var randomNum = ((Math.random () * 2 | 0) + 1) - 1; // random number between 0 and 1​​                    console.log (this.data[randomNum].name + " " + this.data[randomNum].age);                }​            }​            // Assign the showData method of the user object to a variable​            var showDataVar = user.showData;​            showDataVar (); // Samantha 12 (from the global data array, not from the local data array)​ we can fix this problem by specifically setting the “this” value with the bind method:            // Bind the showData method to the user object​            var showDataVar = user.showData.bind (user);​            // Now the we get the value from the user object because the this keyword is bound to the user object​            showDataVar (); // P. Mickelson 43​Bind () Allows us to Borrow Methods       // Here we have a cars object that does not have a method to print its data to the console​            var cars = {                data:[                    {name:"Honda Accord", age:14},                    {name:"Tesla Model S", age:2}                ]​            }​            // We can borrow the showData () method from the user object we defined in the last example.​            // Here we bind the user.showData method to the cars object we just created.​            cars.showData = user.showData.bind (cars);            cars.showData (); // Honda Accord 14​ it is best to borrow a method using either the Apply or Call method.JavaScript’s Bind Allows Us to Curry a Function Function Currying, also known as partial function application, is the use of a function (that accept one or more arguments) that returns a new function with some of the arguments already set. The function that is returned has access to the stored arguments and variables of the outer function. Let’s use the bind () method for currying.function greet (gender, age, name) {    // if a male, use Mr., else use Ms.​    var salutation = gender === "male" ? "Mr. " : "Ms. ";    if (age &gt; 25) {        return "Hello, " + salutation + name + ".";    }    else {        return "Hey, " + name + ".";    }}// So we are passing null because we are not using the "this" keyword in our greet function.​var greetAnAdultMale = greet.bind (null, "male", 45);greetAnAdultMale ("John Hartlove"); // "Hello, Mr. John Hartlove."​var greetAYoungster = greet.bind (null, "", 16);greetAYoungster ("Alex"); // "Hey, Alex."​greetAYoungster ("Emma Waterloo"); // "Hey, Emma Waterloo."​So, with the bind () method, we can explicitly set the this value for invoking methods on objects, we can borrow and copy methods, and assign methods to variable to be executed as functions.JavaScript’s Apply and Call MethodsThe Apply and Call methods are two of the most often used Function methods in JavaScript, and for good reason: they allow us to borrow functions and set the this value in function invocation. In addition, the apply function in particular allows us to execute a function with an array of parameters, such that each parameter is passed to the function individually when the function executes—great for variadic functions; a variadic function takes varying number of arguments, not a set number of arguments as most functions do.Set the this value with Apply or Call// global variable for demonstration​var avgScore = "global avgScore";​//global function​function avg (arrayOfScores) {    // Add all the scores and return the total​    var sumOfScores = arrayOfScores.reduce (function (prev, cur, index, array) {        return prev + cur;    });​    // The "this" keyword here will be bound to the global object, unless we set the "this" with Call or Apply​    this.avgScore = sumOfScores / arrayOfScores.length;}​var gameController = {    scores  :[20, 34, 55, 46, 77],    avgScore:null​}​// If we execute the avg function thus, "this" inside the function is bound to the global window object:​avg (gameController.scores);// Proof that the avgScore was set on the global window object​console.log (window.avgScore); // 46.4​console.log (gameController.avgScore); // null​​// reset the global avgScore​avgScore = "global avgScore";​// To set the "this" value explicitly, so that "this" is bound to the gameController,​// We use the call () method:​avg.call (gameController, gameController.scores);​console.log (window.avgScore); //global avgScore​console.log (gameController.avgScore); // 46.4​ The apply and call methods are almost identical when setting the this value except that you pass the function parameters to apply () as an array, while you have to list the parameters individually to pass them to the call () method. More on this follows. Meanwhile, the apply () method also has another feature that the call () method doesn’t have, as we will soon see.Use Call or Apply To Set this in Callback Functions// Define an object with some properties and a method​// We will later pass the method as a callback function to another function​var clientData = {id: 094545,fullName: "Not Set",// setUserName is a method on the clientData object​setUserName: function (firstName, lastName)  {// this refers to the fullName property in this object​this.fullName = firstName + " " + lastName;}}function getUserInput (firstName, lastName, callback, callbackObj) {// The use of the Apply method below will set the "this" value to callbackObj​callback.apply (callbackObj, [firstName, lastName]);} The Apply method sets the this value to callbackObj. This allows us to execute the callback function with the this value set explicitly, so the parameters passed to the callback function will be set on the clientData object:// The clientData object will be used by the Apply method to set the "this" value​getUserInput ("Barack", "Obama", clientData.setUserName, clientData);// the fullName property on the clientData was correctly set​console.log (clientData.fullName); // Barack Obama​Examples of Borrowing Functions with Apply and Call (A Must Know)"
    } ,
  
    {
      "title"    : "Object Oriented Programming (OOP)",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/07/OOP-in-JavaScript.html",
      "date"     : "2015-09-07 00:00:00 -0700"
     "content"  : "Extrct form JavaScriptissexyObject Oriented Programming (OOP) refers to using self-contained pieces of code to develop applications. We call these self-contained pieces of code objects, better known as Classes in most OOP programming languages and Functions in JavaScript.Building applications with objects allows us to adopt some valuable techniques, namely, Inheritance (objects can inherit features from other objects), Polymorphism (objects can share the same interface—how they are accessed and used—while their underlying implementation of the interface may differ), and Encapsulation (each object is responsible for specific tasks).In this article, we are concerned with only Inheritance and Encapsulation since only these two concepts apply to OOP in JavaScript, particularly because, in JavaScript, objects can encapsulate functionalities and inherit methods and properties from other objects.These two techniques: the best technique for creating objects with specialized functionalities (aka Encapsulation) and the best technique for reusing code (aka Inheritance).Encapsulation and Inheritance OverviewObjects can be thought of as the main actors in an application, or simply the main “things” or building blocks that do all the work. As you know by now, objects are everywhere in JavaScript since every component in JavaScript is an Object, including Functions, Strings, and Numbers. We normally use object literals or constructor functions to create objects.Encapsulation refers to enclosing all the functionalities of an object within that object so that the object’s internal workings (its methods and properties) are hidden from the rest of the application. This allows us to abstract or localize specific set of functionalities on objects.Inheritance refers to an object being able to inherit methods and properties from a parent object (a Class in other OOP languages, or a Function in JavaScript).Both of these concepts, encapsulation and inheritance, are important because they allow us to build applications with reusable code, scalable architecture, and abstracted functionalities. Maintainable, scalable, efficient.OOP in JavaScriptThe two important principles with OOP in JavaScript are Object Creation patterns (Encapsulation) and Code Reuse patterns (Inheritance). When building applications, you create many objects, and there exist many ways for creating these objects: you can use the ubiquitous object literal pattern,var myObj = {name: "Richard", profession: "Developer"}; You can use the prototype pattern, adding each method and property directly on the object’s prototype.function Employee () {}​Employee.prototype.firstName = "Abhijit";Employee.prototype.lastName = "Patel";Employee.prototype.startDate = new Date();Employee.prototype.signedNDA = true;Employee.prototype.fullName = function () {console.log (this.firstName + " " + this.lastName); };​​var abhijit = new Employee () //​console.log(abhijit.fullName()); // Abhijit Patel​console.log(abhijit.signedNDA); // trueYou can also use the constructor pattern, a constructor function (Classes in other languages, but Functions in JavaScript).function Employee (name, profession) {​this.name = name;​this.profession = profession;} // Employee () is the constructor function because we use the &lt;em&gt;new&lt;/em&gt; keyword below to invoke it.​​​var richard = new Employee (“Richard”, “Developer”) // richard is a new object we create from the Employee () constructor function.​​console.log(richard.name); //richard​console.log(richard.profession); // DeveloperThese two universal principles—creating objects (especially from constructor Functions) and allowing objects to inherit properties and methods—are the main focus of this article and, indeed, the main concepts with OOP in JavaScript. We first discuss the object creation pattern.Encapsulation in JavaScript#####(The Best Object Creation Pattern: Combination Constructor/Prototype Pattern)As discussed above, one of the main principles with OOP is encapsulation: put all the inner workings of an object inside that object.Why Encapsulation?whenever you want to create objects with similar functionalities (to use the same methods and properties), you encapsulate the main functionalities in a Function and you use that Function’s constructor to create the objects. This is the essence of encapsulation.Implementation of Combination Constructor/Prototype Patternfunction User (theName, theEmail) {    this.name = theName;    this.email = theEmail;    this.quizScores = [];    this.currentScore = 0;}​User.prototype = {    constructor: User, //have to set manually,since constructor property changes     saveScore:function (theScoreToAdd)  {        this.quizScores.push(theScoreToAdd)    },    showNameAndScores:function ()  {        var scores = this.quizScores.length &gt; 0 ? this.quizScores.join(",") : "No Scores Yet";        return this.name + " Scores: " + scores;    },    changeEmail:function (newEmail)  {        this.email = newEmail;        return "New Email Saved: " + this.email;    }}// A User ​firstUser = new User("Richard", "Richard@examnple.com"); firstUser.changeEmail("RichardB@examnple.com");firstUser.saveScore(15);firstUser.saveScore(10); ​firstUser.showNameAndScores(); //Richard Scores: 15,10​​​// Another User​secondUser = new User("Peter", "Peter@examnple.com");secondUser.saveScore(18);secondUser.showNameAndScores(); //Peter Scores: 18The one disadvantage of overwriting the prototype is that the constructor property no longer points to the prototype, so we have to set it manually. Hence this line:With this pattern, you can use the standard operators and methods on the instances, including the instanceOf operator, the for-in loop (even hasOwnProperty), and the constructor property.Inheritance in JavaScript#####(The Best Pattern: Parasitic Combination Inheritance)Object.create methodObject.create = function (o) {​//It creates a temporary constructor F()​        function F() {        }​//And set the prototype of the this constructor to the parametric (passed-in) o object​​//so that the F() constructor now inherits all the properties and methods of o​        F.prototype = o;​​//Then it returns a new, empty object (an instance of F())​​//Note that this instance of F inherits from the passed-in (parametric object) o object. ​​//Or you can say it copied all of the o object's properties and methods​        return new F();    }The crux of the matter with this Object.create method is that you pass into it an object that you want to inherit from, and it returns a new object that inherits from the object you passed into it. For example:// We have a simple cars object​​var cars = {    type:"sedan",    wheels:4​};​​// We want to inherit from the cars object, so we do:​​var toyota = Object.create (cars); // now toyota inherits the properties from cars​console.log(toyota.type); // sedanThe next function we will use for inheritance is the inheritPrototype function. This function succinctly implements the parasitic combination inheritance for us. We pass in the parent object (or Super Class) and the child object (or Sub Class), and the function does the parasitic combination inheritance: makes the child object inherits from the parent object. function inheritPrototype(childObject, parentObject) {    // As discussed above, we use the Crockford’s method to copy the properties and methods from the parentObject onto the childObject​​// So the copyOfParent object now has everything the parentObject has ​    var copyOfParent = Object.create(parentObject.prototype);​    //Then we set the constructor of this new object to point to the childObject.​​// Why do we manually set the copyOfParent constructor here, see the explanation immediately following this code block.​    copyOfParent.constructor = childObject;​    // Then we set the childObject prototype to copyOfParent, so that the childObject can in turn inherit everything from copyOfParent (from parentObject)​   childObject.prototype = copyOfParent;}Why did we manually set the copyOfParent.constructor?We explicitly set the copyOfParent.constructor property to point to the childObject constructor because in the preceding step, var copyOfParent = Object.create(parentObject.prototype), this is what we actually did:// We made a new object and overwrote its prototype with the parentObject prototype:​​function F() {        }F.prototype = parentObject.prototype;​// Then it was this new F object we assigned to copyOfParent.​​// All of this was done inside the Object.create () method.So, this new F object, which we assigned to copyOfParent, doesn’t have a constructor property anymore because we overwrote its entire prototype. Whenever you overwrite an object’s prototype (object.prototype = someVal), you also overwrite the object’s constructor property.To make sure we have the correct value for copyOfParent constructor, we set it manually with this: copyOfParent.constructor = childObject;  Essentially, we are copying all the properties and methods from theparentObject to the childObject, but we are using the copyOfParent asan intermediary for the copy. And because the childObject prototypewas overwritten during the copy, we manually set the copyOfParentconstructor to the childObject. Then we set the childObject prototypeto the copyOfParent so that the childObject inherits from theparentObject."
    } ,
  
    {
      "title"    : "JavaScript Prototype",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/07/JavaScript-Prototype.html",
      "date"     : "2015-09-07 00:00:00 -0700"
     "content"  : "Extract from javascriptissexy      Every JavaScript function has a prototype property (this property is empty by default), and you attach properties and methods on this prototype property when you want to implement inheritance. Firefox and most versions of Safari and Chrome have a proto “pseudo” property, you should know that it exists and it is simply a way to access an object’s prototype property in some browsers        The second concept with prototype in JavaScript is the prototype attribute.An object’s prototype attribute points to the object’s “parent”—the object it inherited its properties from. To expound on this: Every object inherits properties from some other object, and it is this other object that is the object’s prototype attribute or “parent”.    A constructor is a function used for initializing new objects, and youuse the new keyword to call the constructor.Moreover, all objects thatinherit from another object also inherit a constructor property. Andthis constructor property is simply a property (like any variable)that holds or points to the constructor of the object.//The constructor in this example is Object ()var myObj = new Object ();// And if you later want to find the myObj constructor:console.log(myObj.constructor); // Object()// Another example: Account () is the constructorvar userAccount = new Account (); // Find the userAccount object's constructorconsole.log(userAccount.constructor); // Account()Prototype Attribute of Objects Created with new Object () or Object LiteralAll objects created with object literals and with the Object constructor inherits from Object.prototype. Therefore, Object.prototype is the prototype attribute (or the prototype object) of all objects created with new Object () or with {}. Object.prototype itself does not inherit any methods or properties from any other object.// The userAccount object inherits from Object and as such its prototype attribute is Object.prototype.var userAccount = new Object ();// This demonstrates the use of an object literal to create the userAccount object; the userAccount object inherits from Object; therefore, its prototype attribute is Object.prototype just as the userAccount object does above.var userAccount = {name: “Mike”} Prototype Attribute of Objects Created With a Constructor FunctionObjects created with the new keyword and any constructor other than the Object () constructor, get their prototype from the constructor function.function Account () {}var userAccount = new Account () // userAccount initialized with the Account () constructor and as such its prototype attribute (or prototype object) is Account.prototype.Similarly, any array such as var myArray = new Array (), gets its prototype from Array.prototype and it inherits Array.prototype’s properties.So, there are two general ways an object’s prototype attribute is set when an object is created:  If an object is created with an object literal (var newObj = {}), it inherits properties from Object.prototype and we say its prototype object (or prototype attribute) is Object.prototype.  If an object is created from a constructor function such as new Object (), new Fruit () or new Array () or new Anything (), it inherits from that constructor (Object (), Fruit (), Array (), or Anything ()). For example, with a function such as Fruit (), each time we create a new instance of Fruit (var aFruit = new Fruit ()), the new instance’s prototype is assigned the prototype from the Fruit constructor, which is Fruit.prototype.Any object that was created with new Array () will have Array.prototype as its prototype. An object created with new Fruit () will have Fruit.prototype as its prototype. And any object created with the Object constructor (Obj (), such as var anObj = new Object() ) inherits from Object.prototype.It is important to know that in ECMAScript 5, you can create objects with an Object.create() method that allows you to set the new object’s prototype object.Why is Prototype Important and When is it Used?These are two important ways the prototype is used in JavaScript, as we noted above:1. Prototype Property: Prototype-based InheritancePrototype is important in JavaScript because JavaScript does not have classical inheritance based on Classes (as most object oriented languages do), and therefore all inheritance in JavaScript is made possible through the prototype property. JavaScript has a prototype-based inheritance mechanism.Inheritance is a programming paradigm where objects (or Classes in some languages) can inherit properties and methods from other objects (or Classes). In JavaScript, you implement inheritance with the prototype property. For example, you can create a Fruit function (an object, since all functions in JavaScript are objects) and add properties and methods on the Fruit prototype property, and all instances of the Fruit function will inherit all the Fruit’s properties and methods.function Plant () {​this.country = "Mexico";​this.isOrganic = true;}​​// Add the showNameAndColor method to the Plant prototype property​Plant.prototype.showNameAndColor =  function () {console.log("I am a " + this.name + " and my color is " + this.color);}​​// Add the amIOrganic method to the Plant prototype property​Plant.prototype.amIOrganic = function () {​if (this.isOrganic)console.log("I am organic, Baby!");}​​function Fruit (fruitName, fruitColor) {​this.name = fruitName;​this.color = fruitColor;}​​// Set the Fruit's prototype to Plant's constructor, thus inheriting all of Plant.prototype methods and properties.​Fruit.prototype = new Plant ();​​// Creates a new object, aBanana, with the Fruit constructor​​var aBanana = new Fruit ("Banana", "Yellow");​​// Here, aBanana uses the name property from the aBanana object prototype, which is Fruit.prototype:​console.log(aBanana.name); // Banana​​​// Uses the showNameAndColor method from the Fruit object prototype, which is Plant.prototype. The aBanana object inherits all the properties and methods from both the Plant and Fruit functions.​console.log(aBanana.showNameAndColor()); // I am a Banana and my color is yellow.Indeed, any object that uses the Fruit () constructor will inherit all the Fruit.prototype properties and methods and all the properties and methods from the Fruit’s prototype, which is Plant.prototype. This is the principal manner in which inheritance is implemented in JavaScript and the integral role the prototype chain has in the process.2. Prototype Attribute: Accessing Properties on ObjectsPrototype is also important for accessing properties and methods of objects. The prototype attribute (or prototype object) of any object is the “parent” object where the inherited properties were originally defined.This is loosely analogous to the way you might inherit your surname from your father—he is your “prototype parent.” If we wanted to find out where your surname came from, we would first check to see if you created it yourself; if not, the search will move to your prototype parent to see if you inherited it from him. If it was not created by him, the search continues to his father (your father’s prototype parent).Similarly, if you want to access a property of an object, the search for the property begins directly on the object. If the JS runtime can’t find the property there, it then looks for the property on the object’s prototype—the object it inherited its properties from.If the property is not found on the object’s prototype, the search for the property then moves to prototype of the object’s prototype (the father of the object’s father—the grandfather). And this continues until there is no more prototype (no more great-grand father; no more lineage to follow). This in essence is the prototype chain: the chain from an object’s prototype to its prototype’s prototype and onwards. And JavaScript uses this prototype chain to look for properties and methods of an object.If the property does not exist on any of the object’s prototype in its prototype chain, then the property does not exist and undefined is returned.This prototype chain mechanism is essentially the same concept we have discussed above with the prototype-based inheritance, except we are now focusing specifically on how JavaScript accesses object properties and methods via the prototype object.var myFriends = {name: "Pete"};// To find the name property below, the search will begin directly on the myFriends object and will immediately find the name property because we defined the property name on the myFriend object. This could be thought of as a prototype chain with one link.console.log(myFriends.name);// In this example, the search for the toString () method will also begin on the myFriends’ object, but because we never created a toString method on the myFriends object, the compiler will then search for it on the myFriends prototype (the object which it inherited its properties from).// And since all objects created with the object literal inherits from Object.prototype, the toString method will be found on Object.prototype—see important note below for all properties inherited from Object.prototype. myFriends.toString ();  Object.prototype Properties Inherited by all Objects All objects inJavaScript inherit properties and methods from Object.prototype. Theseinherited properties and methods are constructor, hasOwnProperty (),isPrototypeOf (), propertyIsEnumerable (), toLocaleString (), toString(), and valueOf (). ECMAScript 5 also adds 4 accessor methods toObject.prototype.function People () {this.superstar = "Michael Jackson";}// Define "athlete" property on the People prototype so that "athlete" is accessible by all objects that use the People () constructor.People.prototype.athlete = "Tiger Woods";var famousPerson = new People ();famousPerson.superstar = "Steve Jobs";// The search for superstar will first look for the superstar property on the famousPerson object, and since we defined it there, that is the property that will be used. Because we have overwritten the famousPerson’s superstar property with one directly on the famousPerson object, the search will NOT proceed up the prototype chain. console.log (famousPerson.superstar); // Steve Jobs// Note that in ECMAScript 5 you can set a property to read only, and in that case you cannot overwrite it as we just did.// This will show the property from the famousPerson prototype (People.prototype), since the athlete property was not defined on the famousPerson object itself.​console.log (famousPerson.athlete); // Tiger Woods// In this example, the search proceeds up the prototype chain and find the toString method on Object.prototype, from which the Fruit object inherited—all objects ultimately inherits from Object.prototype as we have noted before.console.log (famousPerson.toString()); // [object Object]All built-in constructors (Array (), Number (), String (), etc.) were created from the Object constructor, and as such their prototype is Object.prototype."
    } ,
  
    {
      "title"    : "JavaScript Variable Scope and Hoisting",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/06/Variable-Scope-n-Hoisting.html",
      "date"     : "2015-09-06 00:00:00 -0700"
     "content"  : "Extract from javascriptissexyVariable ScopeDefinition: A variable’s scope is the context in which the variable exists. The scope specifies from where you can access a variable and whether you have access to the variable in that context.Variables have either a local scope or a global scope.Local Variables (Function-level scope)Variables declared within a function are local variables and are only accessible within that function or by functions inside that function.      No Block-Level Scope(variables scoped to surrounding curly brackets) example: variable in function without “var” is to be a global variable.        Local Variables Have Priority Over Global Variables in FunctionsIf you declare a global variable and a local variable with the same name, the local variable will have priority when you attempt to use the variable inside a function (local scope)      var name = "Paul";  function users () {      // Here, the name variable is local and it takes precedence over the same name variable in the global scope​  var name = "Jack";  // The search for name starts right here inside the function before it attempts to look outside the function in the global scope​  console.log (name);   }  users (); // Jack  Global VariablesAll variables declared outside a function are in the global scope. In the browser, which is what we are concerned with as front-end developers, the global context or scope is the window object (or the entire HTML document).  If a variable is initialized (assigned a value) without first being declared with the var keyword, it is automatically added to the global context and it is thus a global variablePay attention to i:for (var i = 1; i &lt;= 10; i++) {	console.log (i); // outputs 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;};// The variable i is a global variable and it is accessible in the following function with the last value it was assigned above ​function aNumber () {console.log(i);}// The variable i in the aNumber function below is the global variable i that was changed in the for loop above. Its last value was 11, set just before the for loop exited:aNumber ();  // 11  setTimeout Variables are Executed in the Global ScopeNote that all functions in setTimeout are executed in the global scope. This is a tricky bit; consider this:// The use of the “this” object inside the setTimeout function refers to the Window object, not to myObj​var highValue = 200;var constantVal = 2;var myObj = {	highValue: 20,	constantVal: 5,	calculateIt: function () { setTimeout (function  () {	console.log(this.constantVal * this.highValue);}, 2000);	}}// The "this" object in the setTimeout function used the global highValue and constantVal variables, because the reference to "this" in the setTimeout function refers to the global window object, not to the myObj object as we might expect.​myObj.calculateIt(); // 400// This is an important point to remember.Do not Pollute the Global Scopeyou have to know that it is important to avoid creating many variables in the global scope, such as this:// These two variables are in the global scope and they shouldn't be herevar firstName, lastName;function fullName () {	console.log ("Full Name: " + firstName + " " + lastName );}This is the improved code and the proper way to avoid polluting the global scope// Declare the variables inside the function where they are local variablesfunction fullName () {	var firstName = "Michael", lastName = "Jackson";	console.log ("Full Name: " + firstName + " " + lastName );}Variable HoistingAll variable declarations are hoisted (lifted and declared) to the top of the function, if defined in a function, or the top of the global context, if outside a function.It is important to know that only variable declarations are hoisted to the top, not variable initialization or assignments (when the variable is assigned a value).Variable Hoisting Example:function showName () {console.log ("First Name: " + name);var name = "Ford";console.log ("Last Name: " + name);}showName (); // First Name: undefined// Last Name: Ford// The reason undefined prints first is because the local variable name was hoisted to the top of the function​// Which means it is this local variable that get calls the first time.// This is how the code is actually processed by the JavaScript engine:function showName () {	var name; // name is hoisted (note that is undefined at this point, since the assignment happens below)console.log ("First Name: " + name); // First Name: undefinedname = "Ford"; // name is assigned a value// now name is Fordconsole.log ("Last Name: " + name); // Last Name: Ford}Function Declaration Overrides Variable Declaration When HoistedBoth function declaration and variable declarations are hoisted to the top of the containing scope. And function declaration takes precedence over variable declarations (but not over variable assignment). As is noted above, variable assignment is not hoisted, and neither is function assignment. As a reminder, this is a function assignment: var myFunction = function () {}.Here is a basic example to demonstrate:// Both the variable and the function are named myNamevar myName;function myName () {console.log ("Rich");}// The function declaration overrides the variable nameconsole.log(typeof myName); // function ------ // But in this example, the variable assignment overrides the function declarationvar myName = "Richard"; // This is the variable assignment (initialization) that overrides the function declaration.function myName () {console.log ("Rich");}console.log(typeof myName); // string It is important to note that function expressions, such as the example below, are not hoisted.var myName = function () {console.log ("Rich");} In strict mode, an error will occur if you assign a variable a value without first declaring the variable. Always declare your variables."
    } ,
  
    {
      "title"    : "JavaScript Closure",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/06/Closure.html",
      "date"     : "2015-09-06 00:00:00 -0700"
     "content"  : "Extract from javascriptissexyWhat is a closure?A closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.The inner function has access not only to the outer function’s variables, but also to the outer function’s parameters. Note that the inner function cannot call the outer function’s arguments object, however, even though it can call the outer function’s parameters directly.function showName (firstName, lastName) {var nameIntro = "Your name is ";    // this inner function has access to the outer function's variables, including the parameterfunction makeFullName () {       return nameIntro + firstName + " " + lastName;    }return makeFullName ();}showName ("Michael", "Jackson"); // Your name is Michael JacksonClosures are used extensively in Node.js; they are workhorses in Node.js’ asynchronous, non-blocking architecture. Closures are also frequently used in jQuery and just about every piece of JavaScript code you read.$(function() {var selections = []; $(".niners").click(function() { // this closure has access to the selections variable​selections.push (this.prop("name")); // update the selections variable in the outer function's scope​});});      Closures’ Rules and Side EffectsClosures have access to the outer function’s variable even after the outer function returns:When functions in JavaScript execute, they use the same scope chain that was in effect when they were created. This means that even after the outer function has returned, the inner function still has access to the outer function’s variables. Therefore, you can call the inner function later in your program. This example demonstrates:     function celebrityName (firstName) {     var nameIntro = "This celebrity is ";     // this inner function has access to the outer function's variables, including the parameter​    function lastName (theLastName) {         return nameIntro + firstName + " " + theLastName;     }     return lastName; }     var mjName = celebrityName ("Michael"); // At this juncture, the celebrityName outer function has returned.     // The closure (lastName) is called here after the outer function has returned above // Yet, the closure still has access to the outer function's variables and parameter mjName ("Jackson"); // This celebrity is Michael Jackson            Closures store references to the outer function’s variables; they do not store the actual value.  Closures get more interesting when the value of the outer function’s variable changes before the closure is called. And this powerful feature can be harnessed in creative ways, such as this private variables example first demonstrated by Douglas Crockford:      function celebrityID () {     var celebrityID = 999;     // We are returning an object with some inner functions     // All the inner functions have access to the outer function's variables     return {         getID: function ()  {             // This inner function will return the UPDATED celebrityID variable             // It will return the current value of celebrityID, even after the changeTheID function changes it           return celebrityID;         },         setID: function (theNewID)  {             // This inner function will change the outer function's variable anytime​             celebrityID = theNewID;         }     }     }     var mjID = celebrityID (); // At this juncture, the celebrityID outer function has returned. mjID.getID(); // 999 mjID.setID(567); // Changes the outer function's variable mjID.getID(); // 567: It returns the updated celebrityId variable        Closures Gone AwryBecause closures have access to the updated values of the outer function’s variables, they can also lead to bugs when the outer function’s variable changes with a for loop. Thus:     // This example is explained in detail below (just after this code box). function celebrityIDCreator (theCelebrities) {     var i;     var uniqueID = 100;     for (i = 0; i &lt; theCelebrities.length; i++) {       theCelebrities[i]["id"] = function ()  {         return uniqueID + i;       }     }             return theCelebrities; }     var actionCelebs = [{name:"Stallone", id:0}, {name:"Cruise", id:0}, {name:"Willis", id:0}];     var createIdForActionCelebs = celebrityIDCreator (actionCelebs);     var stalloneID = createIdForActionCelebs [0];console.log(stalloneID.id()); // 103  In the preceding example, by the time the anonymous functions are called, the value of i is 3 (the length of the array and then it increments). The number 3 was added to the uniqueID to create 103 for ALL the celebritiesID. So every position in the returned array get id = 103, instead of the intended 100, 101, 102.The reason this happened was because, as we have discussed in the previous example, the closure (the anonymous function in this example) has access to the outer function’s variables by reference, not by value. So just as the previous example showed that we can access the updated variable with the closure, this example similarly accessed the i variable when it was changed, since the outer function runs the entire for loop and returns the last value of i, which is 103To fix this side effect (bug) in closures, you can use an Immediately Invoked Function Expression (IIFE), such as the following:function celebrityIDCreator (theCelebrities) {    var i;    var uniqueID = 100;    for (i = 0; i &lt; theCelebrities.length; i++) {        theCelebrities[i]["id"] = function (j)  { // the j parametric variable is the i passed in on invocation of this IIFE​            return function () {                return uniqueID + j; // each iteration of the for loop passes the current value of i into this IIFE and it saves the correct value to the array​            } () // BY adding () at the end of this function, we are executing it immediately and returning just the value of uniqueID + j, instead of returning a function.        } (i); // immediately invoke the function passing the i variable as a parameter    }    return theCelebrities;}var actionCelebs = [{name:"Stallone", id:0}, {name:"Cruise", id:0}, {name:"Willis", id:0}];var createIdForActionCelebs = celebrityIDCreator (actionCelebs);var stalloneID = createIdForActionCelebs [0];console.log(stalloneID.id); // 100var cruiseID = createIdForActionCelebs [1];console.log(cruiseID.id); // 101"
    } ,
  
    {
      "title"    : "Understand JavaScript Callback Functions and Use Them",
      "category" : "",
      "tags"     : "",
      "url"      : "/javascript/2015/09/04/callback.html",
      "date"     : "2015-09-04 00:00:00 -0700"
     "content"  : "(Learn JavaScript Higher-order Functions, aka Callback Functions)by Richard BovellIn JavaScript, functions are first-class objects; that is, functions are of the type Object and they can be used in a first-class manner like any other object (String, Array, Number, etc.) since they are in fact objects themselves. They can be “stored in variables, passed as arguments to functions, created within functions, and returned from functions”  Because functions are first-class objects, we can pass a function asan argument in another function and later execute that passed-infunction or even return it to be executed later. This is the essenceof using callback functions in JavaScript.In the rest of this article we will learn everything about JavaScript callback functions. Callback functions are probably the most widely used functional programming technique in JavaScript, and you can find them in just about every piece of JavaScript and jQuery code, yet they remain mysterious to many JavaScript developers. The mystery will be no more, by the time you finish reading this article.Callback functions are derived from a programming paradigm known as functional programming. At a fundamental level, functional programming specifies the use of functions as arguments. Functional programming was—and still is, though to a much lesser extent today—seen as an esoteric technique of specially trained, master programmers.Fortunately, the techniques of functional programming have been elucidated so that mere mortals like you and me can understand and use them with ease. One of the chief techniques in functional programming happens to be callback functions. As you will read shortly, implementing callback functions is as easy as passing regular variables as arguments. This technique is so simple that I wonder why it is mostly covered in advanced JavaScript topics.What is a Callback or Higher-order Function?A callback function, also known as a higher-order function, is a function that is passed to another function (let’s call this other function “otherFunction”) as a parameter, and the callback function is called (or executed) inside the otherFunction. A callback function is essentially a pattern (an established solution to a common problem), and therefore, the use of a callback function is also known as a callback pattern.Consider this common use of a callback function in jQuery://Note that the item in the click method's parameter is a function, not a variable.​//The item is a callback function$("#btn_1").click(function() {  alert("Btn 1 Clicked");});As you see in the preceding example, we pass a function as a parameter to the click method. And the click method will call (or execute) the callback function we passed to it. This example illustrates a typical use of callback functions in JavaScript, and one widely used in jQuery.Ruminate on this other classic example of callback functions in basic JavaScript:var friends = ["Mike", "Stacy", "Andy", "Rick"];friends.forEach(function (eachName, index){console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick​});Again, note the way we pass an anonymous function (a function without a name) to the forEach method as a parameter.So far we have passed anonymous functions as a parameter to other functions or methods. Lets now understand how callbacks work before we look at more concrete examples and start making our own callback functions.###How Callback Functions Work?We can pass functions around like variables and return them in functions and use them in other functions.When we pass a callback function as an argument to another function, we are only passing the function definition. We are not executing the function in the parameter. In other words, we aren’t passing the function with the trailing pair of executing parenthesis () like we do when we are executing a function.And since the containing function has the callback function in its parameter as a function definition, it can execute the callback anytime.Note that the callback function is not executed immediately. It is “called back” (hence the name) at some specified point inside the containing function’s body. So, even though the first jQuery example looked like this://The anonymous function is not being executed there in the parameter. //The item is a callback function$("#btn_1").click(function() {  alert("Btn 1 Clicked");});the anonymous function will be called later inside the function body. Even without a name, it can still be accessed later via the arguments object by the containing function.Callback Functions Are ClosuresWhen we pass a callback function as an argument to another function, the callback is executed at some point inside the containing function’s body just as if the callback were defined in the containing function. This means the callback is a closure. Read my post, Understand JavaScript Closures With Ease for more on closures. As we know, closures have access to the containing function’s scope, so the callback function can access the containing functions’ variables, and even the variables from the global scope.Basic Principles when Implementing Callback FunctionsWhile uncomplicated, callback functions have a few noteworthy principles we should be familiar with when implementing them.Use Named OR Anonymous Functions as CallbacksIn the earlier jQuery and forEach examples, we used anonymous functions that were defined in the parameter of the containing function. That is one of the common patterns for using callback functions. Another popular pattern is to declare a named function and pass the name of that function to the parameter. Consider this:// global variable​​var allUserData = [];​​// generic logStuff function that prints to console​​function logStuff (userData) {	if ( typeof userData === "string")	{		console.log(userData);	}	else if ( typeof userData === "object")	{		for (var item in userData) {			console.log(item + ": " + userData[item]);		}​	}​}​​// A function that takes two parameters, the last one a callback function​​function getInput (options, callback) {	allUserData.push (options);	callback (options);​}​​// When we call the getInput function, we pass logStuff as a parameter.​​// So logStuff will be the function that will called back (or executed) inside the getInput function​getInput ({name:"Rich", speciality:"JavaScript"}, logStuff);​//  name: Rich​​// speciality: JavaScriptPass Parameters to Callback FunctionsSince the callback function is just a normal function when it is executed, we can pass parameters to it. We can pass any of the containing function’s properties (or global properties) as parameters to the callback function. In the preceding example, we pass options as a parameter to the callback function. Let’s pass a global variable and a local variable://Global variable​​var generalLastName = "Clinton";​​function getInput (options, callback) {	allUserData.push (options);​// Pass the global variable generalLastName to the callback function​	callback (generalLastName, options);}Make Sure Callback is a Function Before Executing ItIt is always wise to check that the callback function passed in the parameter is indeed a function before calling it. Also, it is good practice to make the callback function optional.Let’s refactor the getInput function from the previous example to ensure these checks are in place.function getInput(options, callback) {	allUserData.push(options);​	// Make sure the callback is a function​	if (typeof callback === "function") {	// Call it, since we have confirmed it is callable​		callback(options);	}}Without the check in place, if the getInput function is called either without the callback function as a parameter or in place of a function a non-function is passed, our code will result in a runtime error.Problem When Using Methods With The this Object as CallbacksWhen the callback function is a method that uses the this object, we have to modify how we execute the callback function to preserve the this object context. Or else the this object will either point to the global window object (in the browser), if callback was passed to a global function. Or it will point to the object of the containing method.Let’s explore this in code: // Define an object with some properties and a method​​// We will later pass the method as a callback function to another function​​var clientData = {	id: 094545,	fullName: "Not Set",	// setUserName is a method on the clientData object​	setUserName: function (firstName, lastName)  {		// this refers to the fullName property in this object​	  this.fullName = firstName + " " + lastName;	}}​​function getUserInput(firstName, lastName, callback)  {	// Do other stuff to validate firstName/lastName here​​	// Now save the names​	callback (firstName, lastName);}In the following code example, when clientData.setUserName is executed, this.fullName will not set the fullName property on the clientData object. Instead, it will set fullName on the window object, since getUserInput is a global function. This happens because the this object in the global function points to the window object.getUserInput ("Barack", "Obama", clientData.setUserName);​console.log (clientData.fullName);// Not Set​​​// The fullName property was initialized on the window object​console.log (window.fullName); // Barack ObamaUse the Call or Apply Function To Preserve thisWe can fix the preceding problem by using the Call or Apply function (we will discuss these in a full blog post later). For now, know that every function in JavaScript has two methods: Call and Apply. And these methods are used to set the this object inside the function and to pass arguments to the functions.Call takes the value to be used as the this object inside the function as the first parameter, and the remaining arguments to be passed to the function are passed individually (separated by commas of course). The Apply function’s first parameter is also the value to be used as the this object inside the function, while the last parameter is an array of values (or the arguments object) to pass to the function.This sounds complex, but lets see how easy it is to use Apply or Call. To fix the problem in the previous example, we will use the Apply function thus://Note that we have added an extra parameter for the callback object, called "callbackObj"​​function getUserInput(firstName, lastName, callback, callbackObj)  {	// Do other stuff to validate name here​​	// The use of the Apply function below will set the this object to be callbackObj​	callback.apply (callbackObj, [firstName, lastName]);}With the Apply function setting the this object correctly, we can now correctly execute the callback and have it set the fullName property correctly on the clientData object:// We pass the clientData.setUserName method and the clientData object as parameters. The clientData object will be used by the Apply function to set the this object​ getUserInput ("Barack", "Obama", clientData.setUserName, clientData);​​// the fullName property on the clientData was correctly set​console.log (clientData.fullName); // Barack ObamaWe would have also used the Call function, but in this case we used the Apply function.Multiple Callback Functions AllowedWe can pass more than one callback functions into the parameter of a function, just like we can pass more than one variable. Here is a classic example with jQuery’s AJAX function:function successCallback() {	// Do stuff before send​}​​function successCallback() {	// Do stuff if success message received​}​​function completeCallback() {	// Do stuff upon completion​}​​function errorCallback() {	// Do stuff if error received​}​$.ajax({	url:"http://fiddle.jshell.net/favicon.png",	success:successCallback,	complete:completeCallback,	error:errorCallback​});“Callback Hell” Problem And SolutionIn asynchronous code execution, which is simply execution of code in any order, sometimes it is common to have numerous levels of callback functions to the extent that you have code that looks like the following. The messy code below is called callback hell because of the difficulty of following the code due to the many callbacks. I took this example from the node-mongodb-native, a MongoDB driver for Node.js. [2]. The example code below is just for demonstration:var p_client = new Db('integration_tests_20', new Server("127.0.0.1", 27017, {}), {'pk':CustomPKFactory});p_client.open(function(err, p_client) {	p_client.dropDatabase(function(err, done) {		p_client.createCollection('test_custom_key', function(err, collection) {			collection.insert({'a':1}, function(err, docs) {				collection.find({'_id':new ObjectID("aaaaaaaaaaaa")}, function(err, cursor) {					cursor.toArray(function(err, items) {						test.assertEquals(1, items.length);​						// Let's close the db​						p_client.close();					});				});			});		});	});});You are not likely to encounter this problem often in your code, but when you do—and you will from time to time—here are two solutions to this problem. [3]Name your functions and declare them and pass just the name of the function as the callback, instead of defining an anonymous function in the parameter of the main function.Modularity: Separate your code into modules, so you can export a section of code that does a particular job. Then you can import that module into your larger application.###Make Your Own Callback FunctionsNow that you completely (I think you do; if not it is a quick reread :)) understand everything about JavaScript callback functions and you have seen that using callback functions are rather simple yet powerful, you should look at your own code for opportunities to use callback functions, for they will allow you to:      Do not repeat code (DRY—Do Not Repeat Yourself)    Implement better abstraction where you can have more generic functions that  are versatile (can handle all sorts of functionalities)    Have better maintainability    Have more readable code    Have more specialized functions.  It is rather easy to make your own callback functions. In the following example, I could have created one function to do all the work: retrieve the user data, create a generic poem with the data, and greet the user. This would have been a messy function with much if/else statements and, even still, it would have been very limited and incapable of carrying out other functionalities the application might need with the user data.Instead, I left the implementation for added functionality up to the callback functions, so that the main function that retrieves the user data can perform virtually any task with the user data by simply passing the user’s full name and gender as parameters to the callback function and then executing the callback function.In short, the getUserInput function is versatile: it can execute all sorts of callback functions with myriad of functionalities.// First, setup the generic poem creator function; it will be the callback function in the getUserInput function below.​​function genericPoemMaker(name, gender) {	console.log(name + " is finer than fine wine.");	console.log("Altruistic and noble for the modern time.");	console.log("Always admirably adorned with the latest style.");	console.log("A " + gender + " of unfortunate tragedies who still manages a perpetual smile");}​​//The callback, which is the last item in the parameter, will be our genericPoemMaker function we defined above.​​function getUserInput(firstName, lastName, gender, callback) {	var fullName = firstName + " " + lastName;​	// Make sure the callback is a function​	if (typeof callback === "function") {	// Execute the callback function and pass the parameters to it​	callback(fullName, gender);	}}Call the getUserInput function and pass the genericPoemMaker function as a callback:getUserInput("Michael", "Fassbender", "Man", genericPoemMaker);​// Output​​/* Michael Fassbender is finer than fine wine.Altruistic and noble for the modern time.Always admirably adorned with the latest style.A Man of unfortunate tragedies who still manages a perpetual smile.*/Because the getUserInput function is only handling the retrieving of data, we can pass any callback to it. For example, we can pass a greetUser function like this:function greetUser(customerName, sex)  {   var salutation  = sex &amp;&amp; sex === "Man" ? "Mr." : "Ms.";  console.log("Hello, " + salutation + " " + customerName);}​​// Pass the greetUser function as a callback to getUserInput​​getUserInput("Bill", "Gates", "Man", greetUser);​​// And this is the output​Hello, Mr. Bill GatesWe called the same getUserInput function as we did before, but this time it performed a completely different task.As you see, callback functions afford much versatility. And even though the preceding example is relatively simple, imagine how much work you can save yourself and how well abstracted your code will be if you start using callback functions. Go for it. Do it in the monings; do it in the evenings; do it when you are down; do it when you are kNote the following ways we frequently use callback functions in JavaScript, especially in modern web application development, in libraries, and in frameworks:   For asynchronous execution (such as reading files, and making HTTP requests)  In Event Listeners/Handlers  In setTimeout and setInterval methods  For Generalization: code concisenessFinal WordsJavaScript callback functions are wonderful and powerful to use and they provide great benefits to your web applications and code. You should use them when the need arises; look for ways to refactor your code for Abstraction, Maintainability, and Readability with callback functions.See you next time, and remember to keep coming back because JavaScriptIsSexy.com has much to teach you and you have much to learn."
    } ,
  
    {
      "title"    : "HTML5 material",
      "category" : "",
      "tags"     : "",
      "url"      : "/front_end/2015/08/04/interview-notes.html",
      "date"     : "2015-08-04 00:00:00 -0700"
     "content"  : "New features in HTML5HTML 5 New Doctype and CharsetHTML 5 New Structure &lt;section&gt;，&lt;article&gt;，&lt;nav&gt;，&lt;header&gt;，&lt;footer&gt;，&lt;aside&gt;HTML 5 New Inline ElementsThese inline elements define some basic concepts and keep them semantically marked up, mostly to do with time:  &lt;figcaption&gt;   。HTML 5 New Form Types: datetime,datetime-local,date,month,week,time,number,range,email,url新增的表单元素：:定义下拉列表，和配合使用。:密钥对生成器。:output 元素用于不同类型的输出，比如计算或脚本输出。新增的form标签属性：autocomplete属性（自动完成）和novalidate属性（规定在提交表单时不应该验证 form 或 input 域）HTML 5 New Dynamic Pages SupportContext menus href async attribute    HTML 5 New Elements   HTML 5 Removes Some Elementsacronymappletbasefontbigcenterdirfontframeframesetisindexnoframesnoscriptsstrikettu"
    } ,
  
    {
      "title"    : "Aha, this is my first blog",
      "category" : "",
      "tags"     : "",
      "url"      : "/interests/2015/07/10/first-blog.html",
      "date"     : "2015-07-10 14:47:49 -0700"
     "content"  : "以下功能还需要修改一下下搜索功能搜索框目前只是摆设，请使用 Google Custom Search Engine 或 jekyll-lunr-js-search 插件。修改邮箱通过 Stop Link Spam Bots 编辑了邮箱地址，希望能防 spam。Embedding Codepen如果需要插入 Codepen，只需将 embed code 中的 &lt;p&gt; 部分粘贴在正文中，而不必粘贴 &lt;script&gt; 部分。更多关于插入 Codepen 的解释请查看 http://blog.codepen.io/documentation/features/how-do-i-embed-a-pen-on-another-site/ 。如果完全不需要这个功能可以将 /assets/js/script.js 中的相关代码删除。修改分享链接地址打开 /_layouts/post.html 将分享链接中的 place_your_url_here 提换成博客地址。修改许可协议在 /_layouts/post.html 文件的分享链接部分声明博客内容所使用的许可协议，默认使用 Attribution-NonCommercial-ShareAlike 3.0 Unported。设置 RSS请不要忘记编辑 rss.xml 文件，语言可填 zh-cn 或 zh-tw。"
    } 
  
]
